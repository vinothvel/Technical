1. What is UBOOT?
   Uboot is first and second stage bootloader. U-Boot performs both first-stage
(e.g., Initial CPU configurations, configuring memory controllers and RAM configurations and loads the uboot into DDR memory) and 
second-stage booting (Loading of kernel). 
e.g U-Boot runs a command-line interface on a console or a serial port. Using the CLI, users can load and boot a kernel, possibly changing parameters from the default.       U-Boot requires its boot commands to explicitly specify the physical memory addresses as destinations for copying data (kernel, ramdisk, device tree, etc.) and for jumping to the kernel and as arguments for the kernel. 
    It manages several internal and external devices such as NAND and NOR Flash memories, Ethernet and USB.
    It supports FTP (IP Stack), FAT, UBIFS(File system).

2. What is devicetree?
   A device tree is simply a tree structure of nodes and properties. Properties are key-value pairs and may contain bothproperties and child nodes
   Device tree is a data structure for describing hardware layout. During the Linux boot process, a "Device Tree Blob" (DTB) file is loaded into memory by U-Boot / UEFI, and a pointer to it is passed to the kernel. This DTB file describes the system's hardware layout to the Linux kernel, allowing for platform-specific code to be moved out of the kernel sources and replaced with generic code that can parse the DTB and configure the system as required.Device Tree Source (DTS) files are simple text files that can be compiled into a binary Device Tree Blob (DTB) format using the Device Tree Compiler (DTC) tool.
   Decompiling a DTB using DTC is lossless, i.e. one can decompile a DTB into a DTS and then compile that DTS back into a DTB without losing any information.
  eg : memory mapping and interrupt pin controls.


3. What is initial ramdisk?
   initrd (initial ramdisk) is a scheme for loading a temporary root file system into memory, which may be used as part of the Linux startup process. initrd and initramfs refer to two different methods of achieving this. Both are commonly used to make preparations before the real root file system can be mounted.

4. Boot process of Linux?
   1). BIOS 
   On power on BIOS will run and configure the system interfaces such as RAM and performs POST. Once POST is completed it starts looking for primary/first level boot loader called MBR(Master Boot Record). Once MBR is loded then control is given to MBR.

  2) MBR (Master Boot Record)
  Master boot record contains bootloader info, partition table and MBR validation bytes.
MBR is 512 bytes. MBR then loads the GRUB bootloder and transfer the control.

  3) GRUP (Grand Unified BootLoader)
  This is second level bootloader. It shows splash screen if mutiple os is installed in a system. Once Os is selected it loads the kerner and initial ramdisk and transfer the control to kernel. 

  4) Kernel
  Mounts the root file system and runs /sbin/init program. This program has process ID 1.
Kernel uses the initial ram disk as temporary root file system until the real ramdisk or root filesystem is mounted.

  5) Init
  Once the kernel loads the init program, kernel executes the list of deamon process based on the default run level using /etc/inittab. There are 6 levels are available,
0 - shutdown
1 - single user
2 - multi user, without NFS
3 - Full Multi user
4 - unused
5 - X11
6 - reboot

  For each run level there is a directory in /etc/rc.d/rc0.d/.. In these directory there will be programs starts with S for running at startup and K for running at shutdown. Each program has number in which sequence it should be started and killed.
 
5. What is kernel module?
   Kernel module is an object which can loaded to the kernel without rebooting or changing the kernel. It is more like extending the kernel functionality dynamically for the new hardware or module.

6. What happens when we do insmod?
   -> Insmod function will call init_module function with file len and parameters to initmate the user is trying to load kernel modules.
   -> Once the kernel takes control then kernel calls sys_init_module function which does the following,
      * Check the user has permission to load the module
      * using copy_from-user call kernel copies the data from user space to kernel space along with the user arguments.
      * It checks the validity of the copied ELF file.
      * Symbol Resolution is done.
      * Then the module reference is added the module list(LinkedList)
   -> Then module init function of the driver is called.   
      
7. What happens when we do rmmod?
   -> rmmod function will call the delete_module function which hints the kernel module about the rmmod request and transfer the control to kernel.
   -> Kernel then calls sys_delete_module function which does the following work,
      * check the user has permission to unload the module.
      * check the module is anybody else is using 
      * check the module is module is still alive
   -> It execute module_exit function
   -> free_module function will be called.
      * Removes any sys_fs reference
      * Removes the object reference and platform specific cleanup
      * Free up the memory.

8. Difference between sysfs and procfs?
   -> /Proc was originally used to export about the process information and some of the key attributes (system information eg cpuinfo, meminfo) for utilities such as ps, top. free etc.. Over the time due to the easy nature of access for both kernel and user space it grown more like dumping ground for lot of information. Hence it was decided to go for structured manner for this exporting.
   -> /sys was structured one and when ever new driver is registerd it will make entry is sysfs. So using this sysfs we can communicate with device also. In sysfs it is more like virtual file which directly reflected to the device driver.
   
9. Spin Lock?
   -> Spinlock uses busy wait mechanism to keep the thread alive without context switching, Hence spin lock mostly to be used where the requirement and usage for the resouce will be very minimal. Spin lock can be acquire by user and kernel process as well. User process spin lock can be pre empted where as kernel spinlock can not. So when we keep the spinlock in user process for longer time there may be a chance it may get pre empted by the OS scheduler. 
   In kernel process when spin lock is used pre emption is disabled hence no other process can pre empt this process. This is suited only for multi core CPU. In Single core CPU spin lock only does the busy wait, pre emption will not be disabled.
   
10. Mutex?   

11. What is IOCTL?
    -> Device drivers supports standard file operations such as open, read, write... etc. But when there is need for customised operation there are two ways, One is using sysfs file entry and other one is IOCTL. IOCTL is a function (Input and Output Contorl) which accepts the command code and arguments as parameter from user space.
    -> Compact_IOCTL is used for allowing 32bit user space programs to access 64bit drivers.
     
12. What is user space and kernel space?
    -> To protect the memory access each process memory is split into two. User memory is accessble only for user mode programs and kernel memory is accesbile only for kernel mode. Using system calls (0x86) Trap instruction user mode is switched to kernel mode. User mode has certain restriction such as it can not modify page table of an process this enusures one process can not modify or access another process memory.
    
13. How system call works?


14. What is symbol resolution?
    Symbol Resolution is executable file when loaded into memory will make reference to an entity/functions which are not defined internally. Eg.
    We may be using library call and this function call may link to the library on symbol resolution stage. 


In built driver from where it is starting and loading?
how to pass data to driver without ioctl or file operations? eg (Sysfs and dev)
kernel source code structures?

How to use register as pointer?
 Every microprocessor or controller has two set of memory regions for the registers. 1. Memory mapped and non memory mapped register. 
 -> Non memory mapped registers does not have any memory address to access and it can be access by using the register name in assembly language or using inline assembly instruction in c program. eg. Program counter register, stack pointer register. 
 -> Where as memory mapped registers are mapped to the particular section of the main memory hence it can be accessed using normal pointer.
 Eg. If GPIO pin base address is 0x8000000, then it can be accessed two ways 1. using pointer variable, 2. converting the address pointer const by casting.
  1. volatile unsinged int* GPIO_REG = (unsigned int *)0x800000; or volatile unsinged int* const GPIO_REG = (unsigned int *)0x800000;
  2. *(volatile unsinged int*)0x8000000 = (any value);
 -> In both cases volatile should be used to avoid optimization.
 
Can we store Register variable address in pointer? 
 -> When we declare a varible as register it assigns the variable into the CPU register which is non memory mapped.
 -> Since CPU registers doesnt have the address, we can not have the address the register variable and store in a pointer.
 
Global variable storge in register?
  -> The compiler enables you to use the register storage class specifier to store global variables in general-purpose registers. These variables are called global named register variables.
   Syntax : register int *foo __asm("r12") 
   -> here it is apparently tells the compiler that it should use register r12 to store the variable foo.
   -> But global variables can not initalized 
   -> Do not use type qualifiers such as const and volatile, as the outcome may be contrary to expectations. In particular, using the volatile qualifier does not fully prevent the compiler from optimizing accesses to the register. 

Register limit? what happens if it exceeds?
 -> When CPU register are fully utilized, then it converts the variables into auto or stack memory. 
 -> There is no limit on how many register variables can be used in a program.
 
How to search file in folder using cmd?
 -> syntax : find /path option filename
 -> ex: find /home -type f -name "*.conf"
 
string search cmd?
 -> grep -rnw '/path/to/somewhere/' -e 'pattern' - Returns the file containing the string.
 
dmesg command?
recursion?
booting sequence?
platform drivers will load in uboot or kernel?
what thigs will load in uboot and kernel?
platform drivers?
Stack overflow?
Fork?
