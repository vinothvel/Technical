----------------------------------
1. Circular Queue Using Array
----------------------------------
#include <stdio.h>
#include <stdlib.h>

#define MAX_CAPACITY    5

int arr[MAX_CAPACITY] = {0};
int front = -1, rear  = -1;

int EnQueue(int value)
{
    if(front == ((rear + 1) % MAX_CAPACITY))
    {
        return -1;
    }
    
    if(front == -1)
    {
        front = 0;
    }
    
    rear = ((rear + 1) % MAX_CAPACITY);
    arr[rear] = value;
}

int DeQueue()
{
    if(front == -1)
    {
        return -1;
    }
    
    if(front == rear)
    {
        rear = -1;
        front  = -1;
    }
    else
    {
        front = ((front + 1) % MAX_CAPACITY);
    }
}

int display()
{
    int i = 0;
    
    if(front == -1)
    {
        return -1;
    }
    
    for(i = front; i != front; (i = (i+1) % MAX_CAPACITY))
    {
        printf("%d - ", arr[i]);
    }
    printf("%d - \r\n", arr[i]);
}

int main()
{
    DeQueue();
    EnQueue(10);
    display();   
}

----------------------------------
2. Circular Queue Using Linked List
----------------------------------
#include <stdio.h>
#include <stdlib.h>

#define MAX_CAPACITY    5

typedef struct QNODE
{
    int key;
    //`int *next;
    struct QNODE* next;
}QNODE;

typedef struct
{
    QNODE *front, *rear;
    int size;
}QUEUE;

int EnQueue(QUEUE *q, int value)
{
    QNODE *ptr = NULL;
    
    if(q->size == MAX_CAPACITY)
    {
        /*Queue Full*/
        return -1;
    }
    
    ptr = (QNODE *)malloc(sizeof(QNODE));
    ptr->key = value;
    if(q->front == NULL)
    {
        q->front = ptr;
        q->front->next = NULL;
        
        q->rear = ptr;
    }
    else
    {
        q->rear->next = ptr;
    }
    
    q->size++;
    q->rear = ptr;
    q->rear->next = q->front;
}

int DeQueue(QUEUE *q)
{
    QNODE *ptr = NULL;
    if(q->front == NULL)
    {
        return -1;
    }
    
    ptr = q->front;
    
    if(q->front == q->rear)
    {
        q->front = NULL;
        q->rear = NULL;
        
        q->size = 0;
    }
    else
    {
       q->size--;
       q->front = q->front->next;
       q->rear->next = q->front;
    }
    
    free(ptr);
}

int display(QUEUE *q)
{
    QNODE *ptr = NULL;
    
    if(q->front == NULL)
    {
        return -1;
    }
    
    for(ptr = q->front; ptr != q->rear; ptr = ptr->next)
    {
        printf("%d - ", ptr->key);
    }
    
    printf("%d\n", ptr->key);

}

int main()
{
    QUEUE *q = NULL;
    
    q = malloc(sizeof(QUEUE));
    
    q->size = 0;
    q->front = NULL;
    q->rear = NULL;
    
    EnQueue(q, 10);
    
    display(q);
    
    EnQueue(q, 15);
    EnQueue(q, 4);
    EnQueue(q, 2);
    EnQueue(q, 1);
    DeQueue(q);
    EnQueue(q, 12);
    display(q);
}

----------------------------------
3. Queue using Stack
----------------------------------
#include <stdio.h>
#include <stdlib.h>

#define MAX_CAPACITY    5

int s1[MAX_CAPACITY] = {0};
int s2[MAX_CAPACITY] = {0};

int s1_top = -1;
int s2_top = -1;

int pop1()
{
    int a = s1[s1_top];
    s1_top--;
    return a;
}

int pop2()
{
    return s2[s2_top--];
}

int push1(int value)
{
    s1[++s1_top] = value;
}

int push2(int value)
{
    s2[++s2_top] = value;
}

int EnQueue(int value)
{
    if(s1_top == (MAX_CAPACITY - 1))
    {
        return -1;
    }
    
    push1(value);
}

int Dequeue()
{
    int i = 0;
    int count = 0;
    if(s1_top == -1)
    {
        return -1;
    }
    
    count = s1_top;
    for(i = 0; i <= count; i++)
    {
        push2(pop1());
    }
    
    display2();
    pop2();
    
    count = s2_top;
    for(i = 0; i <= count; i++)
    {
        push1(pop2());
    }
}

int display()
{
    int i = 0;
    
    for(i = 0; i <= s1_top; i++)
    {
        printf("%d - ", s1[i]);
    }
    
    printf("\n");
}

int display2()
{
    int i = 0;
    
    for(i = 0; i <= s2_top; i++)
    {
        printf("%d - ", s2[i]);
    }
    
    printf("\n");
}


int main()
{
    EnQueue(10);
    EnQueue(9
    EnQueue(8);
    EnQueue(7);
    EnQueue(6);
    display();
    Dequeue();
    display();
    EnQueue(5);
    
    display();
    EnQueue(4);   
}
