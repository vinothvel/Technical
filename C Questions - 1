1) Find size of variable in generic form
  #define sizeof( var) ((char *)(&var + 1) - (char *)(&var))
  
  Find size of struct?
  struct test *a = NULL;
  printf("size of : %d\r\n", a++); // will print the struct size.
  
  
2) Inline Function vs Macro
  Macro is expanded in the preprocessor time. It is just text substituion and also macros are not type checked where as inline function does.
  eg : #define MAX(a,b) ((a)>(b) ? (a) : (b))
    int i = 5, j = MAX(i++, 0); will be int i = 5, j = ((i++)>(0) ? (i++) : (0));.
  The macro arguments are not evaluated before macro expansion. Eg: Max(2+3, 5+2);  
  Inline function replaces the function call with actual body of the function. Inline is just a request to a compiler.
  Advantage of inline function is, it does not require function call and does not return anything from the function.
  Disadvantage of inline function is, it increases file size as same function code is copied again and again in the program wherever it is called.
 
3) unnamed structure?
Anonymous or unnames structures are used in nested union or structures. Since there is no name defined directly it can be accessed.

Usage : Memory representation.
typedef struct {
    union{
        struct {uint8_t a, b, g, r;};
        uint32_t val;
    };
}Color;

4) What is the use of function pointers? array of function pointers?
Funtion Pointer :
----------------------
int fun(char a) {}

int (*fun_ptr)(char) = &fun; // Initialization
*fun_ptr(10); // Function calling
OR
int (*fun_ptr)(char) = fun; // Initialization
fun_ptr(10); // Function calling

int (*fun)() -> function pointer () - > is important. Because without () it looks like int * return type.

Usage:
1) Function pointers can be useful when you want to create callback mechanism, and need to pass address of a function to another function.
2) To avoid code redundancy we use function pointers. With same input performing different functionalities.
3) Like normal pointers we can use function pointer as argument. This 

5) Difference between size of and strlen?
   Sizeof will give the sizeof of datatype and it is done at compilation time and Sizeof of will not consider the value inside the variable.
   Where as strlen is used for strings will give the value or null terminated string length of an variable.
              Eg : char arra[20] = "vinoth" - sizeof of will return 20. But strlen will return 7.

6) What is the difference between memory mapped and io mapped?
   Memory Mapped IO :
   1) Memory address space is assigned from main memory to the IO for the requested Size. Changes in the memory will directly affect the IO states.
   2) Normal read and write CPU INSTRUCTION cycles are used. 
   IO Mapped IO :
   1) IO will be mapped to the IO addresses. This state can be read or write using the registers / CPU address.
   2) IO read / IO Write instructions will be used.
   
7) How to allocate memory for double pointer?
   Double pointers ppoints to memory location of an another pointer.
          Eg : char **p = malloc((char*) * 100); // will holds memory for 100 pointers.
              char *p[0] =  malloc(); // can be done.

8) What is RISC and CISC?
   
   RISC (Reduced Instruction Set Computer)
    Main Idea behind the RISC is to reduce hardware complexity by using simpler instructions. Reduces the CPU cycle at the cost of number of instructions.
    Since there is no need for complex instruction decoding logic, more number of transistors can be used thus increases the number of registers.
    No of registers reduces the memory access time. Executes one instrution per clock cycle.
   
   CISC (Complex Instruction Set Computer)
    When working in Assembly language for programming there was need of instruction to perform multiple work. Hence CISC is introduced.
    Main Idea behing the CISC is one instrcution will do all loading, evaluating and storing operations. Reduces the number of instruction at the cost of
    CPU cycles. Takes more than one cycle to execute instructions.
    
9) What are processor architecture available?
    1) Von-Neumann
    2) Harvard
    3) CISC
    4) RISC
    5) DSP - MAC (Multiply and Accumulate) and Shifter (Arithmetic and Logical shift) units are added to the DSP cores since Signal Processing Algorithms
    heavily depend on such operations. Circular Buffers, Bit Reversal Addressing, Hardware Loops, and DAG (Digital Address Generators) are some other common 
    features of a DSP Architecture. Since Signal Processing Applications are data intensive, the data I/O bandwidth of these processors is designed to be high.
    
    Microcontroller Architectures :
    1) ARM
    2) AVR
    3) PIC
    4) 8051
    5) Power PC
    Micro Processor Architectures :
    1) X86
    2) ARM
    3) Power PC
    
    ARM : Advanced RISC machine
    Special family of instruction set architecture based on RISC architecture.
    
    AVR : 
    AVR is modified Harvard architecture 8-bit RISC single-chip microcontrollers.
    
    PIC :
    PIC Microcontroller architecture is based on Harvard architecture and supports RISC architecture
    
    Power PC :
    is a reduced instruction set computer (RISC) instruction set architecture
    
10) const volatile int *p can be used?
    Yes. Volatile indicates the program to fetch data always from memory nor from registers. Const indicates we can not change its value. 
    So incase of Hardware register which is supposed to be filled by other module can be given as const volatile in our program.
    
    How const qualifier acheives the non editable value?
    Const qualifier stores the variable data in .ro or text segment. But when we try to change using the pointer, 
    compiler gives the warning and discards the const qualifier.
    
    eg : char* str = "data";  /*Constant char will be stored in .ro section of c memory segment*/  
          strcpy(str, "copy"); /*Since this is trying to access ro memory, will give segment fault.*/

11) Macro for endian swap?
    #define Swap_endian(data)   \
    ((((data) >> 24) 0xFF) | (((data) >> 8) & 0xFF00) | \
    (((data) << 24) 0xFF000000) | (((data) << 8) & 0xFF0000))
    
12) Structure Padding and Packing ?
    By default all processor architecture mandates the data should be aligned. Because unalligned memory access is slower(ie wastage of read cycles).
    This alignment is done at the cost of memory. Eg: In 32Bit CPU, in one CPU cycle 4bytes of memory can be read. When it is not aligned in multiples of 4bytes
    an integer varibale will be stored in the 2block os 4byte aligned memory hence it woould require 2 read cycle. This leads to slower operation.
    
    Hence all structures are aligned to its address boundaries. This is called structure padding. 
    Packing explicitley intiamates the compiler to avoid / do packing for the desired value. #pragma pack.
    Note : Normally structure would padd the values to the size of an variable with max size of the datatype available in that structure.
    
    structure padding is done to avoid performance penalty when accessing data from memory. It is padded to the highest datatype size available in the structure. 
    
13) Typedef vs Macro?
     Typedef is limited to giving alias name for the data type only. Interpretation is performed in compilation time.
     Typedef follows the scope rule.
     Macros can give alias name for literals, constants and type also. Interpretation is done in preprocessing time.
     Macros does not have any scope rule.
     
14) C Compilation Steps:
      i) Preprocessing - (*.i) Expansion of macros, Conditional compilation, Comments removal and Include file expansion
         -> Output of the preprocessing is expanded code called translation unit.
         -> Translation unit defines the scope of the file. Eg. static global variable is limited to this translation unit called internal linkage. And this static 
         variable name may not be visible to the linker.
         -> where as global variable may be visible to the linker.
      ii) Compilation - (*.s file) - Object code
      iii) Assmbly Code - Assemble language (*.o)
      iv) Linker - (ELF or executable file)
      
15) How two variables with same name is differentiated?
    Variables names are appended with function name or line no to diffrentiate the variables internally by the compiler. This can be seen using objdump.

16) When we include header file more than once? what happens?
    -> Normally all headers should be coded with conditional header such as #ifdef. In this case header file will be included only once.
    -> If conditional macros are not avaiable then compiler might throw error for redefinition.

17) Behind Main function?
    -> When we look at the ELF file e_entry address main is not the entry function. it is _start.
    -> Compiler generaly designed to encode this assembly instruction to our code.
    -> Job of the _start function is to setup the stack for the main function with parameters, 
    prepare the memory layout for storing the global variables and calls the main.
  
  We can override this feature. ie. function can be defined without main function.
		int nomain();
    
		void _start() {
    nomain();
		}

		int nomain(){
		    printf("My func");
		}

	-> compile this function with -nostartfilesin gcc.
 
18) Difference Between Type Casting and Type Conversion?
    Type casting is done when converting the larger datatype to smaller one. It is done at the time of coding.
    Type conversion is done by compiler at the time of compilation. This is done when smaller datatype is converted to larger one.
    
19) Pointer Arithemetic ?
    Pointer arithmetic *p++ --> due to operator precedence both *, ++ is equal and associativity is right to left. Hence --> *(p++);

20) Const pointers?
    int *const ptr; --> constant pointer. 
   const int *ptr; or int const *ptr; --> pointer to a constant;
   const int *const ptr; --> constant pointer to const;
   
21) Double pointer memory allocation?
    int **a;
	
	a = (int **)malloc(sizeof(int *) * 4);
	
	for(4)
	 a[0] = (int *)malloc(sizeof(int) * 2);

	Now the double pointer can be accessed like --> a[i][j]. 
  --> Double Pointer and one malloc call.
   	
   	/*Allocates memory of r double pointer and c*r int memory*/
   	a = (int **)malloc( (sizeof(int *) * r) + (sizeof(int) * c * r) )	
	  ptr = (int *)(a + r);
	
	  for(i = 0;i < r)
		  a[i] = ((ptr + c) * i);

22) Processor stack frame?
	> each function consists of an stack and the layout of the stack follows,
		function parameters --> Lower memory and grows downwards
		function return address
		last function base pointer
		local variables
		buffer
		callee save registers (last functions registers value) to be restored when it goes back to old function	
	Ref : https://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html
	
23) A functions variable can be accessed from another function without passing address?


Ref: https://www.2braces.com/c-questions/pointer-questions-c-8    
    

what is pci BAR?
PCI enumuration?
Design logic for producer 1GHz and consumer 650MHz no data should be lost and no flow conttroles should be used.
what is uboot
what is device tree and can we convert dtb into dts.
