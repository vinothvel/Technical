Reference : https://www.techiedelight.com/bit-hacks-part-3-playing-rightmost-set-bit-number/

Tricks with Bits :

x & (x-1) will clear the lowest set bit of x
x & ~(x-1) extracts the lowest set bit of x (all others are clear).
x & (x + (1 << n)) = x, with the run of set bits (possibly length 0) starting at bit n cleared.
x & ~(x + (1 << n)) = the run of set bits (possibly length 0) in x, starting at bit n.
x | (x + 1) = x with the lowest cleared bit set.
x | ~(x + 1) = extracts the lowest cleared bit of x (all others are set).
x | (x - (1 << n)) = x, with the run of cleared bits (possibly length 0) starting at bit n set.
x | ~(x - (1 << n)) = the lowest run of cleared bits (possibly length 0) in x, starting at bit n are the only clear bits.


How to check if a given number is a power of 2 ?
 
int IsPowerOf2(int x)
{
  /* Normal Implementation*/
  if(x == 0)
    return 0;
    
    while((x % 2) == 0)
      x /= 2;
      
      return (x==1);
      
   /*Bit Manipulation. if x is a power of 2 then x & (x-1) will be 0.*/
   return (x && !(x & (x - 1)));
}

2) Count the number of ones in the binary representation of the given number?

int CountHigh_Bits(int x)
{
   int count = 0;
   
   /* Normal Implementation*/
   while(x)
   {
     x = x/2;
     count++;
   }
   
   if(x == 1)
    count ++;
   
   return count;
   
   /*Bit Manipulation*/
   /* (x & (x-1)) will clear the rightmost high bit */
   while(x)
   {
     x = (x & (x-1));
     count++;
   }
   
   return count;
}

3)  Check if the ith bit is set in the binary form of the given number.
  
  if(x & (1 << i))
   return true;
  else
   return false;
  
4) Find the Rightmost Bit set in a given number.
   
   Two ways to solve:
   1) x ^ (x & (x -1)) --> (As (x & (x -1)) will clear the rightmost bit) xor with x will return the right most bit.
   2) x & (-x) --> As -x is 2s complement of x will flip all the bits to the MSB bit.
   
   int RightMostBitPosition(int x)
   {
     int Pos;
     x ^= (x & (x -1)); OR 
     
     while(x)
     {
      x >> 1;
      Pos++;
     }
     
     return Pos;
   }
 
5) Clear all bits from LSB to ith bit
 int clear_lsb(int x, int i) 
 {
   /* (x - 1) will clear the msb bit and sets all the LSB bits*/
   int mask = ~((1 << (i+1)) - 1);
   x &= mask;
  
   return x;
 }
 
6) Clearing all bits from MSB to i-th bit
 int clear_msb(int x, int i) 
 {
   /* (x - 1) will clear the msb bit and sets all the LSB bits*/
   int mask = ((1 << (i)) - 1);
   x &= mask;
  
   return x;
 }
 
 7) swap Bits at Odd and Even places
 int swapBit(int x)
 {
  return  ((x & (0xAAAAAAAA)) >> 1) | ((x & 0x55555555) << 1)
 }
 
 
   
