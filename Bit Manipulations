How to check if a given number is a power of 2 ?
 
int IsPowerOf2(int x)
{
  /* Normal Implementation*/
  if(x == 0)
    return 0;
    
    while((x % 2) == 0)
      x /= 2;
      
      return (x==1);
      
   /*Bit Manipulation. if x is a power of 2 then x & (x-1) will be 0.*/
   return (x && !(x & (x - 1)));
}

2) Count the number of ones in the binary representation of the given number?

int CountHigh_Bits(int x)
{
   int count = 0;
   
   /* Normal Implementation*/
   while(x)
   {
     x = x/2;
     count++;
   }
   
   if(x == 1)
    count ++;
   
   return count;
   
   /*Bit Manipulation*/
   /* (x & (x-1)) will clear the rightmost high bit */
   while(x)
   {
     x = (x & (x-1));
     count++;
   }
   
   return count;
}

3)  Check if the ith bit is set in the binary form of the given number.
  
  if(x & (1 << i))
   return true;
  else
   return false;
  
4) Find the Rightmost Bit set in a given number.
   
   Two ways to solve:
   1) x ^ (x & (x -1)) --> (As (x & (x -1)) will clear the rightmost bit) xor with x will return the right most bit.
   2) x & (-x) --> As -x is 2s complement of x will flip all the bits to the rightmost bit.
   
   int RightMostBitPosition(int x)
   {
     int Pos;
     x ^= (x & (x -1)); OR 
     
     while(x)
     {
      x >> 1;
      Pos++;
     }
     
     return Pos;
   }
 
5) Clear all bits from LSB to ith bit
 int clear_lsb(int x, int i) 
 {
   /* (x - 1) will clear the msb bit and sets all the LSB bits*/
   int mask = ~((1 << (i+1)) - 1);
   x &= mask;
  
   return x;
 }
 
6) Clearing all bits from MSB to i-th bit
 int clear_msb(int x, int i) 
 {
   /* (x - 1) will clear the msb bit and sets all the LSB bits*/
   int mask = ((1 << (i)) - 1);
   x &= mask;
  
   return x;
 }
 
 
 
   
